/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import assert from 'assert';
import { ensureNoDisposablesAreLeakedInTestSuite } from '../../../../../base/test/common/utils.js';
import { MAX_FOLDING_REGIONS, FoldingRegions, } from '../../browser/foldingRanges.js';
import { RangesCollector, computeRanges } from '../../browser/indentRangeProvider.js';
import { createTextModel } from '../../../../test/common/testTextModel.js';
const markers = {
    start: /^#region$/,
    end: /^#endregion$/,
};
suite('FoldingRanges', () => {
    ensureNoDisposablesAreLeakedInTestSuite();
    const foldRange = (from, to, collapsed = undefined, source = 0 /* FoldSource.provider */, type = undefined) => ({
        startLineNumber: from,
        endLineNumber: to,
        type: type,
        isCollapsed: collapsed || false,
        source,
    });
    const assertEqualRanges = (range1, range2, msg) => {
        assert.strictEqual(range1.startLineNumber, range2.startLineNumber, msg + ' start');
        assert.strictEqual(range1.endLineNumber, range2.endLineNumber, msg + ' end');
        assert.strictEqual(range1.type, range2.type, msg + ' type');
        assert.strictEqual(range1.isCollapsed, range2.isCollapsed, msg + ' collapsed');
        assert.strictEqual(range1.source, range2.source, msg + ' source');
    };
    test('test max folding regions', () => {
        const lines = [];
        const nRegions = MAX_FOLDING_REGIONS;
        const collector = new RangesCollector({ limit: MAX_FOLDING_REGIONS, update: () => { } });
        for (let i = 0; i < nRegions; i++) {
            const startLineNumber = lines.length;
            lines.push('#region');
            const endLineNumber = lines.length;
            lines.push('#endregion');
            collector.insertFirst(startLineNumber, endLineNumber, 0);
        }
        const model = createTextModel(lines.join('\n'));
        const actual = collector.toIndentRanges(model);
        assert.strictEqual(actual.length, nRegions, 'len');
        model.dispose();
    });
    test('findRange', () => {
        const lines = [
            /* 1*/ '#region',
            /* 2*/ '#endregion',
            /* 3*/ 'class A {',
            /* 4*/ '  void foo() {',
            /* 5*/ '    if (true) {',
            /* 6*/ '        return;',
            /* 7*/ '    }',
            /* 8*/ '',
            /* 9*/ '    if (true) {',
            /* 10*/ '      return;',
            /* 11*/ '    }',
            /* 12*/ '  }',
            /* 13*/ '}',
        ];
        const textModel = createTextModel(lines.join('\n'));
        try {
            const actual = computeRanges(textModel, false, markers);
            // let r0 = r(1, 2);
            // let r1 = r(3, 12);
            // let r2 = r(4, 11);
            // let r3 = r(5, 6);
            // let r4 = r(9, 10);
            assert.strictEqual(actual.findRange(1), 0, '1');
            assert.strictEqual(actual.findRange(2), 0, '2');
            assert.strictEqual(actual.findRange(3), 1, '3');
            assert.strictEqual(actual.findRange(4), 2, '4');
            assert.strictEqual(actual.findRange(5), 3, '5');
            assert.strictEqual(actual.findRange(6), 3, '6');
            assert.strictEqual(actual.findRange(7), 2, '7');
            assert.strictEqual(actual.findRange(8), 2, '8');
            assert.strictEqual(actual.findRange(9), 4, '9');
            assert.strictEqual(actual.findRange(10), 4, '10');
            assert.strictEqual(actual.findRange(11), 2, '11');
            assert.strictEqual(actual.findRange(12), 1, '12');
            assert.strictEqual(actual.findRange(13), -1, '13');
        }
        finally {
            textModel.dispose();
        }
    });
    test('setCollapsed', () => {
        const lines = [];
        const nRegions = 500;
        for (let i = 0; i < nRegions; i++) {
            lines.push('#region');
        }
        for (let i = 0; i < nRegions; i++) {
            lines.push('#endregion');
        }
        const model = createTextModel(lines.join('\n'));
        const actual = computeRanges(model, false, markers);
        assert.strictEqual(actual.length, nRegions, 'len');
        for (let i = 0; i < nRegions; i++) {
            actual.setCollapsed(i, i % 3 === 0);
        }
        for (let i = 0; i < nRegions; i++) {
            assert.strictEqual(actual.isCollapsed(i), i % 3 === 0, 'line' + i);
        }
        model.dispose();
    });
    test('sanitizeAndMerge1', () => {
        const regionSet1 = [
            foldRange(0, 100), // invalid, should be removed
            foldRange(1, 100, false, 0 /* FoldSource.provider */, 'A'), // valid
            foldRange(1, 100, false, 0 /* FoldSource.provider */, 'Z'), // invalid, duplicate start
            foldRange(10, 10, false), // invalid, should be removed
            foldRange(20, 80, false, 0 /* FoldSource.provider */, 'C1'), // valid inside 'B'
            foldRange(22, 80, true, 0 /* FoldSource.provider */, 'D1'), // valid inside 'C1'
            foldRange(90, 101), // invalid, should be removed
        ];
        const regionSet2 = [
            foldRange(20, 80, true), // should merge with C1
            foldRange(18, 80, true), // invalid, out of order
            foldRange(21, 81, true, 0 /* FoldSource.provider */, 'Z'), // invalid, overlapping
            foldRange(22, 80, true, 0 /* FoldSource.provider */, 'D2'), // should merge with D1
        ];
        const result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);
        assert.strictEqual(result.length, 3, 'result length1');
        assertEqualRanges(result[0], foldRange(1, 100, false, 0 /* FoldSource.provider */, 'A'), 'A1');
        assertEqualRanges(result[1], foldRange(20, 80, true, 0 /* FoldSource.provider */, 'C1'), 'C1');
        assertEqualRanges(result[2], foldRange(22, 80, true, 0 /* FoldSource.provider */, 'D1'), 'D1');
    });
    test('sanitizeAndMerge2', () => {
        const regionSet1 = [
            foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), // valid
            foldRange(2, 100, false, 0 /* FoldSource.provider */, 'a2'), // valid
            foldRange(3, 19, false, 0 /* FoldSource.provider */, 'a3'), // valid
            foldRange(20, 71, false, 0 /* FoldSource.provider */, 'a4'), // overlaps b3
            foldRange(21, 29, false, 0 /* FoldSource.provider */, 'a5'), // valid
            foldRange(81, 91, false, 0 /* FoldSource.provider */, 'a6'), // overlaps b4
        ];
        const regionSet2 = [
            foldRange(30, 39, true, 0 /* FoldSource.provider */, 'b1'), // valid, will be recovered
            foldRange(40, 49, true, 1 /* FoldSource.userDefined */, 'b2'), // valid
            foldRange(50, 100, true, 1 /* FoldSource.userDefined */, 'b3'), // overlaps a4
            foldRange(80, 90, true, 1 /* FoldSource.userDefined */, 'b4'), // overlaps a6
            foldRange(92, 100, true, 1 /* FoldSource.userDefined */, 'b5'), // valid
        ];
        const result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);
        assert.strictEqual(result.length, 9, 'result length1');
        assertEqualRanges(result[0], foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), 'P1');
        assertEqualRanges(result[1], foldRange(2, 100, false, 0 /* FoldSource.provider */, 'a2'), 'P2');
        assertEqualRanges(result[2], foldRange(3, 19, false, 0 /* FoldSource.provider */, 'a3'), 'P3');
        assertEqualRanges(result[3], foldRange(21, 29, false, 0 /* FoldSource.provider */, 'a5'), 'P4');
        assertEqualRanges(result[4], foldRange(30, 39, true, 2 /* FoldSource.recovered */, 'b1'), 'P5');
        assertEqualRanges(result[5], foldRange(40, 49, true, 1 /* FoldSource.userDefined */, 'b2'), 'P6');
        assertEqualRanges(result[6], foldRange(50, 100, true, 1 /* FoldSource.userDefined */, 'b3'), 'P7');
        assertEqualRanges(result[7], foldRange(80, 90, true, 1 /* FoldSource.userDefined */, 'b4'), 'P8');
        assertEqualRanges(result[8], foldRange(92, 100, true, 1 /* FoldSource.userDefined */, 'b5'), 'P9');
    });
    test('sanitizeAndMerge3', () => {
        const regionSet1 = [
            foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), // valid
            foldRange(10, 29, false, 0 /* FoldSource.provider */, 'a2'), // matches manual hidden
            foldRange(35, 39, true, 2 /* FoldSource.recovered */, 'a3'), // valid
        ];
        const regionSet2 = [
            foldRange(10, 29, true, 2 /* FoldSource.recovered */, 'b1'), // matches a
            foldRange(20, 28, true, 0 /* FoldSource.provider */, 'b2'), // should remain
            foldRange(30, 39, true, 2 /* FoldSource.recovered */, 'b3'), // should remain
        ];
        const result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);
        assert.strictEqual(result.length, 5, 'result length3');
        assertEqualRanges(result[0], foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), 'R1');
        assertEqualRanges(result[1], foldRange(10, 29, true, 0 /* FoldSource.provider */, 'a2'), 'R2');
        assertEqualRanges(result[2], foldRange(20, 28, true, 2 /* FoldSource.recovered */, 'b2'), 'R3');
        assertEqualRanges(result[3], foldRange(30, 39, true, 2 /* FoldSource.recovered */, 'b3'), 'R3');
        assertEqualRanges(result[4], foldRange(35, 39, true, 2 /* FoldSource.recovered */, 'a3'), 'R4');
    });
    test('sanitizeAndMerge4', () => {
        const regionSet1 = [
            foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), // valid
        ];
        const regionSet2 = [
            foldRange(20, 28, true, 0 /* FoldSource.provider */, 'b1'), // hidden
            foldRange(30, 38, true, 0 /* FoldSource.provider */, 'b2'), // hidden
        ];
        const result = FoldingRegions.sanitizeAndMerge(regionSet1, regionSet2, 100);
        assert.strictEqual(result.length, 3, 'result length4');
        assertEqualRanges(result[0], foldRange(1, 100, false, 0 /* FoldSource.provider */, 'a1'), 'R1');
        assertEqualRanges(result[1], foldRange(20, 28, true, 2 /* FoldSource.recovered */, 'b1'), 'R2');
        assertEqualRanges(result[2], foldRange(30, 38, true, 2 /* FoldSource.recovered */, 'b2'), 'R3');
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9sZGluZ1Jhbmdlcy50ZXN0LmpzIiwic291cmNlUm9vdCI6ImZpbGU6Ly8vVXNlcnMveWFzaGFzbmFpZHUvS3ZhbnRjb2RlL3ZvaWQvc3JjLyIsInNvdXJjZXMiOlsidnMvZWRpdG9yL2NvbnRyaWIvZm9sZGluZy90ZXN0L2Jyb3dzZXIvZm9sZGluZ1Jhbmdlcy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Z0dBR2dHO0FBRWhHLE9BQU8sTUFBTSxNQUFNLFFBQVEsQ0FBQTtBQUMzQixPQUFPLEVBQUUsdUNBQXVDLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQTtBQUVsRyxPQUFPLEVBQ04sbUJBQW1CLEVBRW5CLGNBQWMsR0FFZCxNQUFNLGdDQUFnQyxDQUFBO0FBQ3ZDLE9BQU8sRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLE1BQU0sc0NBQXNDLENBQUE7QUFDckYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDBDQUEwQyxDQUFBO0FBRTFFLE1BQU0sT0FBTyxHQUFtQjtJQUMvQixLQUFLLEVBQUUsV0FBVztJQUNsQixHQUFHLEVBQUUsY0FBYztDQUNuQixDQUFBO0FBRUQsS0FBSyxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUU7SUFDM0IsdUNBQXVDLEVBQUUsQ0FBQTtJQUN6QyxNQUFNLFNBQVMsR0FBRyxDQUNqQixJQUFZLEVBQ1osRUFBVSxFQUNWLFlBQWlDLFNBQVMsRUFDMUMsb0NBQXdDLEVBQ3hDLE9BQTJCLFNBQVMsRUFDbkMsRUFBRSxDQUNILENBQVc7UUFDVixlQUFlLEVBQUUsSUFBSTtRQUNyQixhQUFhLEVBQUUsRUFBRTtRQUNqQixJQUFJLEVBQUUsSUFBSTtRQUNWLFdBQVcsRUFBRSxTQUFTLElBQUksS0FBSztRQUMvQixNQUFNO0tBQ04sQ0FBQSxDQUFBO0lBQ0YsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLE1BQWlCLEVBQUUsTUFBaUIsRUFBRSxHQUFXLEVBQUUsRUFBRTtRQUMvRSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0s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QUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUE7WUFDL0MsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUMvQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO1lBQy9DLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUE7WUFDL0MsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUMvQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO1lBQy9DLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUE7WUFDL0MsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUMvQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO1lBQy9DLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUE7WUFDakQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJ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